<?php
/**
 * MemcachedHelper类
 * @link http://php.net/manual/en/book.memcached.php
 * @author mirrorgdit@gmail.com
 * @package sys.helper
 */
class MemcachedHelper {
    /**
     * 配置数组
     * @var array
     */
    private $_configArr = array();
    /**
     * Memcached的实例
     * @var Memcached
     */
    private $_m;
    /**
     * 是否启用压缩
     * @var bool
     */
    private $_compression = false;
    /**
     * 序列化处理程序
     * @var int Memcached::SERIALIZER_PHP/Memcached::SERIALIZER_JSON/Memcached::SERIALIZER_IGBINARY
     */
    private $_serializer = \Memcached::SERIALIZER_PHP;
    /**
     * Key前缀
     * @var string
     */
    private $_prefixKey = '';
    /**
     * Hash方法
     * @var int Memcached::HASH_DEFAULT/Memcached::HASH_MD5/Memcached::HASH_CRC/Memcached::HASH_FNV1_64/Memcached::HASH_FNV1A_64/Memcached::HASH_FNV1_32/Memcached::HASH_FNV1A_32/Memcached::HASH_HSIEH/Memcached::HASH_MURMUR
     */
    private $_hash = \Memcached::HASH_DEFAULT;

    /**
     * 构造函数
     * @param array $configArr 配置数组array($host, $port)
     */
    public function __construct($configArr) {
        $this->_configArr = array(
            'host' => $configArr[0],
            'port' => $configArr[1],
        );
    }

    /**
     * 获取Memcached的实例
     * @return Memcached
     */
    public function getConn() {
        if (!isset($this->_m)) {
            // 检查扩展模块是否加载
            if (!extension_loaded('memcached')) {
                throw new UserException(UserException::ERROR_EXTENSION_NOT_LOADED, 'Extension(%s) not loaded!', 'memcached');
            }
            // 创建Memcached的实例
            $this->_m = new \Memcached();
            $this->_m->addServer($this->_configArr['host'], $this->_configArr['port']);
            // 选项设置
            $this->_m->setOption(\Memcached::OPT_COMPRESSION, $this->_compression);
            $this->_m->setOption(\Memcached::OPT_SERIALIZER, $this->_serializer);
            $this->_m->setOption(\Memcached::OPT_PREFIX_KEY, $this->_prefixKey);
            $this->_m->setOption(\Memcached::OPT_HASH, $this->_hash);
        }
        return $this->_m;
    }

    /**
     * Add an item under a new key
     * @param string $key The key under which to store the value.
     * @param mixed $val The value to store.
     * @param int $expiration The expiration time, defaults to 0.
     * @return bool Returns TRUE on success or FALSE on failure.
     */
    public function add($key, $val, $expiration = 0) {
        $ret = $this->getConn()->add($key, $val, $expiration) or $this->checkResultCode();
        return $ret;
    }

    /**
     * Append data to an existing item
     * @param string $key The key under which to store the value.
     * @param string $val The string to append.
     * @return bool Returns TRUE on success or FALSE on failure.
     */
    public function append($key, $val) {
        $ret = $this->getConn()->append($key, $val) or $this->checkResultCode();
        return $ret;
    }

    /**
     * Compare and swap an item
     * @param float $casToken Unique value associated with the existing item. Generated by memcache.
     * @param string $key The key under which to store the value.
     * @param mixed $val The value to store.
     * @param int $expiration The expiration time, defaults to 0.
     * @return bool Returns TRUE on success or FALSE on failure.
     */
    public function cas($casToken, $key, $val, $expiration = 0) {
        $ret = $this->getConn()->cas($casToken, $key, $val, $expiration) or $this->checkResultCode();
        return $ret;
    }

    /**
     * Decrement numeric item's value
     * @param string $key The key of the item to decrement.
     * @param int $offset The amount by which to decrement the item's value.
     * @return int/false Returns item's new value on success or FALSE on failure.
     */
    public function decrement($key, $offset = 1) {
        $ret = $this->getConn()->decrement($key, $offset) or $this->checkResultCode();
        return $ret;
    }

    /**
     * Delete an item
     * @param string $key The key to be deleted.
     * @param int $time The amount of time the server will wait to delete the item.
     * @return bool Returns TRUE on success or FALSE on failure.
     */
    public function delete($key, $time = 0) {
        $ret = $this->getConn()->delete($key, $time) or $this->checkResultCode();
        return $ret;
    }

    /**
     * Retrieve an item
     * @param string $key The key of the item to retrieve.
     * @param string $cacheCallback Read-through caching callback or NULL.
     * @param &float $casToken The variable to store the CAS token in.
     * @return mixed Returns the value stored in the cache or FALSE otherwise.
     */
    public function get($key, $cacheCallback = NULL, &$casToken = NULL) {
        $numArgs = func_num_args();
        if ($numArgs === 2) {
            $ret = $this->getConn()->get($key, $cacheCallback) or $this->checkResultCode();
            return $ret;
        } else {
            $ret = $this->getConn()->get($key, $cacheCallback, $casToken) or $this->checkResultCode();
            return $ret;
        }
    }

    /**
     * Retrieve multiple items
     * @param array $keys Array of keys to retrieve.
     * @param &array $casTokens The variable to store the CAS tokens for the found items.
     * @param int $flags The flags for the get operation.
     * @return bool Returns the array of found items or FALSE on failure.
     */
    public function getMulti($keys, &$casTokens = NULL, $flags = \Memcached::GET_PRESERVE_ORDER) {
        $ret = $this->getConn()->getMulti($keys, $casTokens, $flags) or $this->checkResultCode();
        return $ret;
    }

    /**
     * Increment numeric item's value
     * @param string $key The key of the item to increment.
     * @param int $offset The amount by which to increment the item's value.
     * @return int/false Returns new item's value on success or FALSE on failure.
     */
    public function increment($key, $offset = 1) {
        $ret = $this->getConn()->increment($key, $offset) or $this->checkResultCode();
        return $ret;
    }

    /**
     * Prepend data to an existing item
     * @param string $key The key of the item to prepend the data to.
     * @param string $val The string to prepend.
     * @return bool Returns TRUE on success or FALSE on failure.
     */
    public function prepend($key, $val) {
        $ret = $this->getConn()->prepend($key, $val) or $this->checkResultCode();
        return $ret;
    }

    /**
     * Replace the item under an existing key
     * @param string $key The key under which to store the value.
     * @param mixed $val The value to store.
     * @param int $expiration The expiration time, defaults to 0.
     * @return bool The expiration time, defaults to 0.
     */
    public function replace($key, $val, $expiration = 0) {
        $ret = $this->getConn()->replace($key, $val, $expiration) or $this->checkResultCode();
        return $ret;
    }

    /**
     * Store an item
     * @param string $key The key under which to store the value.
     * @param mixed $val The value to store.
     * @param int $expiration The expiration time, defaults to 0.
     * @return bool Returns TRUE on success or FALSE on failure.
     */
    public function set($key, $val, $expiration = 0) {
        $ret = $this->getConn()->set($key, $val, $expiration) or $this->checkResultCode();
        return $ret;
    }

    /**
     * Store multiple items
     * @param array $items An array of key/value pairs to store on the server.
     * @param int $expiration The expiration time, defaults to 0.
     * @return bool Returns TRUE on success or FALSE on failure.
     */
    public function setMulti($items, $expiration = 0) {
        $ret = $this->getConn()->setMulti($items, $expiration) or $this->checkResultCode();
        return $ret;
    }

    /**
     * 检查返回代码(严重错误直接抛出异常,普通错误返回TRUE交给用户自行处理)
     * @return true
     */
    public function checkResultCode() {
        $resultCode = $this->getConn()->getResultCode();
        switch ($resultCode) {
            //case Memcached::RES_SUCCESS:
            //case Memcached::RES_FAILURE:
            case \Memcached::RES_HOST_LOOKUP_FAILURE:
            case \Memcached::RES_UNKNOWN_READ_FAILURE:
            case \Memcached::RES_PROTOCOL_ERROR:
            case \Memcached::RES_CLIENT_ERROR:
            case \Memcached::RES_SERVER_ERROR:
            case \Memcached::RES_WRITE_FAILURE:
                //case Memcached::RES_DATA_EXISTS:
                //case Memcached::RES_NOTSTORED:
                //case Memcached::RES_NOTFOUND:
            case \Memcached::RES_PARTIAL_READ:
                //case Memcached::RES_SOME_ERRORS:
            case \Memcached::RES_NO_SERVERS:
                //case Memcached::RES_END:
            case \Memcached::RES_ERRNO:
                //case Memcached::RES_BUFFERED:
            case \Memcached::RES_TIMEOUT:
            case \Memcached::RES_BAD_KEY_PROVIDED:
            case \Memcached::RES_CONNECTION_SOCKET_CREATE_FAILURE:
            case \Memcached::RES_PAYLOAD_FAILURE:
                throw new UserException(UserException::ERROR_MEMCACHED, 'Memcached error(%d)!', $resultCode);
                break;
            default :
                return true;
        }
    }
}